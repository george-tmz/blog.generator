---
title: "缓存 Cache"
date: 2023-06-28T01:18:13+08:00
draft: true
---

#### 缓存基础
- 通用定义 位于速度相差较大的两种硬件之间，用于协调两者数据传输速度差异的结构 
- 本质 空间换时间
- 为什么用缓存
    1. 提升访问性能
    2. 降低网络拥堵
    3. 减少后端负载
    4. 消除数据库热点
    5. 可预测的性能
    6. 增加系统的可扩展性

#### 缓存的特征指标
##### 命中率
命中率 = 返回正确结果数量/请求缓存次数

命中率越高，缓存使用效率越高

##### 最大空间
缓存中可以存放的最大元素的数量
##### 缓存生存时间TTL
缓存可以存活的时间， 超过时间就消失
##### 缓存清空策略
- FIFO
- LFU
- LRU
- 定时过期
- 懒性过期
- 最长过期
- 最近过期
- 随机过期清理
- 随机清理

#### 常见的几大问题
##### 缓存失效
大批量缓存同时失效
##### 穿透
使用合法的key查询数据，每次都落到DB
##### 雪崩
节点失效 
##### 并发
##### 缓存数据不一致
最终一致
##### 热点缓存

#### 缓存策略（模式）
##### Cache Aside Patten
写数据
- 跟新数据到数DB
- 删除对应的缓存
读数据
- 根据key查询数据缓存未命中
- 根据key查询数据库得到最新值
- 将最新值更新到缓存
适用场景：对数据一致性要求比较高的业务，或者是缓存数据更新比较复杂的业务。

##### Read/Write Through Patten
Cache和DB的读写操作完全由存储服务组件代理完成

写数据
- 先查缓存，如果在缓存不存在，两种策略
  - no-write allication：只直接跟新DB，不会写入缓存
  - write allication：先更新Cache，然后通过存储服务组件更新DB
- 如果数据在Cache中，则先更新Cache，然后通过存储服务组件更新DB
读数据
- 先查询缓存，如果数据在缓存存在则直接返回
- 若不存在，由存储服务组件从数据库中同步加载数据到缓存中

适用场景
 - 对系统有较高的隔离性要求，数据有冷热之分的业务

缺点：同步写数据库延迟较高

##### Write Behind Patten
核心想法：在更新数据的时候，只更新缓存，不更新数据库，缓存会异步批量更新数据库
适用场景：大量写请求，可以合并写请求的业务
缺点：数据一致性差，存在数据丢失的可能